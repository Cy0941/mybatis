<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!--通过 mapper 进行代理 sql 映射-->

<!--
    命名空间：对sql进行分组、隔离
    cxy 使用 mapper 代理方法开发，namespace 设置为对应 mapper.java 的全类名
-->
<mapper namespace="cn.cxy.first.dao.mapper.UserMapper">
    <!--在映射文件中配置sql语句-->


    <select id="findUserList" parameterType="cn.cxy.first.vo.UserQueryVo" resultType="cn.cxy.first.model.UserCustomer">
        SELECT *
        FROM user
        WHERE sex = #{user.sex} AND username LIKE '%${user.username}%'
    </select>

    <select id="findUserCount" parameterType="cn.cxy.first.vo.UserQueryVo" resultType="int">
        SELECT count(*)
        FROM user
        WHERE sex = #{user.sex} AND username LIKE '%${user.username}%'
    </select>

    <!--resultMap使用：在sql返回结果与实际pojo属性名无法一一对应时使用此属性进行转换-->
    <resultMap id="userResultMap" type="user"><!--尝试映射为 type 类型-->
        <id column="id_" property="id"/><!--主键属性单独处理-->
        <result column="username_" property="username"/>
    </resultMap>
    <select id="findUserResultMap" parameterType="cn.cxy.first.vo.UserQueryVo" resultMap="userResultMap">
        SELECT
            id       id_,
            username username_
        FROM user
        WHERE sex = #{user.sex} AND username LIKE '%${user.username}%'
    </select>

    <!--
        id：标识映射文件中的sql - 将SQL语句封装到 mappedStatement对象中，作为statement的id
        parameterType：输入参数类型
        resultType：单条记录输出类型所映射的Java对象 - 字段必须与数据库字段一一对应 TODO 单条记录类型
        #{id}：输入参数名称；cxy 如果参数是基本数据类型，#{}是占位符，其中的参数名可以任意，可以使用value字符或其他支付
        TODO parameterType 所定义的是 java 类型，而在 sql 中实际接收的是 jdbc 类型 - mybatis 使用内置的类型转换器进行了转换（一般情况下不需要进行自定义。可在 sqlMapConfig.xml 中通过 typeHandlers 标签进行只定义 ）
    -->
    <select id="findUserById" parameterType="int" resultType="cn.cxy.first.model.User">
        SELECT *
        FROM user
        WHERE id = #{id}
    </select>

    <!--
        模糊查询：可能返回多条记录
        cxy ${value}：
            1、拼接sql，将接收到的参数内容不加任何修饰拼接在sql中
            2、可能会引起sql注入
            3、${value} 接收输入参数的内容，如果传入的是基本数据类型，${}中只能使用value字符串
    -->
    <select id="findUserByName" parameterType="java.lang.String" resultType="cn.cxy.first.model.User">
        SELECT *
        FROM user
        WHERE username LIKE '%${value}%'
    </select>

    <!--
        数据插入：
            sql 中的 value 值会根据对应的实体类进行自动解析
    -->
    <insert id="addUser" parameterType="cn.cxy.first.model.User">
        INSERT INTO user (username, birthday, sex, address) VALUES (#{username}, #{birthday}, #{sex}, #{address})
    </insert>


    <!--
        cxy 自增主键返回：insert成功后执行 SELECT last_insert_id() 并将值设置到参数 User 中
    -->
    <insert id="autoIncrementId" parameterType="cn.cxy.first.model.User">
        /*
        keyProperty - 对应 insert 标签中 parameterType 属性的属性
        order - 相对 insert 语句执行的顺序
        resultType - 指定返回类型
        */
        <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
            SELECT last_insert_id()
        </selectKey>
        INSERT INTO user(username, birthday, sex, address) VALUES (#{username},#{birthday},#{sex},#{address})
    </insert>

    <!--
        cxy 非自增主键返回：主键为非自增；java.lang.String类型；长度为35
    -->
    <insert id="handleIncrementId" parameterType="cn.cxy.first.model.User">
        /*
        实现原理：先通过 uuid 函数获得主键并设置到参数对应属性，然后在进行 insert 操作
        */
        <selectKey keyProperty="id" order="BEFORE" resultType="java.lang.String">
            SELECT uuid()
        </selectKey>
        INSERT INTO user(id,username, birthday, sex, address) VALUES (#{id},#{username},#{birthday},#{sex},#{address})
    </insert>

    <!--删除用户-->
    <delete id="deleteById" parameterType="java.lang.Integer">
        DELETE FROM user
        WHERE id = #{id}
    </delete>

    <update id="updateUser" parameterType="cn.cxy.first.model.User">
        UPDATE user
        SET username = #{username}, sex = #{sex}, birthday = #{birthday}, address = #{address}
        WHERE id = #{id}
    </update>

</mapper>
